// Please refer to grammar.ebnf for the outline of how the parser works. It is a mandatory read,
// and every change you make here, you must update the grammar with.

//! For using the symbols generated by the lexer and making sense of them in the context of
//! mathematical expressions.

use std::slice::Iter;
use std::iter::Peekable;

use crate::lexer::*;

#[derive(Debug, Clone, PartialEq)]
pub enum Expr<T: Clone> {
    BinOp(Operator, Box<Expr<T>>, Box<Expr<T>>),
    Pow(Box<Expr<T>>, Box<Expr<T>>),
    Neg(Box<Expr<T>>),
    Factorial(Box<Expr<T>>),
    Function(String, Box<Expr<T>>),
    Assignment(String, Box<Expr<T>>),
    Constant(T),
    Identifier(String),
}

impl<T: Clone> Expr<T> {
    /// Replaces all instances of `old` with `new`. Returns the number of elements that have been replaced.
    /// # Example
    /// One could use this function to replace all references to an identifier "x" with the constant `20`.
    /// ```
    /// use rsc::{
    ///     lexer::tokenize,
    ///     parser::{parse, Expr},
    ///     computer::Computer,
    /// };
    /// let tokens = lexer::tokenize("x^2 * 4").unwrap();
    /// let replacement = parser::Expr::Constant(20.);
    /// let mut ast = parser::parse(&tokens).unwrap();
    /// ast.replace(&parser::Expr::Identifier(String::from("x")), &replacement, false);
    /// assert_eq!(Computer::new(std::f64::consts::PI, std::f64::consts::E).compute(&ast), Ok(1600.0);
    /// ```
    #[allow(dead_code)]
    pub fn replace(&mut self, old: &Expr<T>, new: &Expr<T>, ignore_fields: bool) -> u32
            where T: Clone + PartialEq {
        if ignore_fields {
            if std::mem::discriminant(self) == std::mem::discriminant(old) {
                *self = new.clone();
                return 1;
            }
        } else {
            if self == old {
                *self = new.clone();
                return 1;
            }
        }

        let mut replaced = 0;
        match self {
            Expr::BinOp(_, a, b) => {
                replaced += a.replace(old, new, ignore_fields);
                replaced += b.replace(old, new, ignore_fields);
            }
            Expr::Pow(a, b) => {
                replaced += a.replace(old, new, ignore_fields);
                replaced += b.replace(old, new, ignore_fields);
            }
            Expr::Neg(a) => {
                replaced += a.replace(old, new, ignore_fields);
            }
            Expr::Function(_, a) => {
                replaced += a.replace(old, new, ignore_fields);
            }
            _ => {}
        }

        replaced
    }
}

/// # Error Lookup Table
/// | Error ID                   | Description                                                                  |
/// |----------------------------|------------------------------------------------------------------------------|
/// | ExpectedClosingParenthesis | When the input is missing a right parenthesis ')'.                           |
/// | ExpectedClosingPipe        | When the input is missing a final pipe '|' on an abs expression, like: '|-2' |
/// | ExpectedFactor             | Expected to find a definite value like a variable or number, but did not.    |
/// | UnexpectedNumber           | A number was found in place of some other vital structure, ex: '24 3'        |
#[derive(Debug, Clone, PartialEq)]
pub enum ParserError<T> {
    ExpectedClosingParenthesis,
    ExpectedClosingPipe,
    /// Its value is the `Token` that was found instead of a factor.
    ExpectedFactor(Option<Token<T>>),
    UnexpectedNumber(Token<T>),
}
use self::ParserError::*;

pub type ParserResult<T> = Result<Expr<T>, ParserError<T>>;

/// For detecting parsing errors using an iterative solution. This function can tell when
/// users accidentally enter an expression such as "2x" (when they mean "2(x)"). But just
/// as easily detects unknowingly valid expressions like "neg 3" where "neg" is currently
/// `Token::Identifier`.
pub fn preprocess<T: Clone>(tokens: &[Token<T>]) -> Option<ParserError<T>> {
    // Preprocess and preemptive erroring on inputs like "2x"
    let mut t = tokens.iter().peekable();
    while let Some(tok) = t.next() {
        match tok {
            Token::Number(_) => {
                if let Some(peek_tok) = t.peek() {
                    match peek_tok {
                        Token::Identifier(_) => {
                            return Some(UnexpectedNumber((*peek_tok).clone()));
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }
    None
}

/// Turn an array of tokens into an expression, which can be computed into a final number.
pub fn parse<T: Clone>(tokens: &[Token<T>]) -> ParserResult<T> {
    match preprocess(tokens) {
        Some(e) => Err(e),
        None => parse_additive_expr(&mut tokens.iter().peekable()),
    }
}

/// Same as `parse`, except this does not automatically run `preprocess`. There are a few reasons one may use this function:
/// * Performance or timing
/// * AST will have identifiers that act as functions
/// * You have your own preprocess function
/// If you are not sure, use default `parse` instead.
#[allow(dead_code)]
pub fn parse_no_preprocess<T: Clone>(tokens: &[Token<T>]) -> ParserResult<T> {
    parse_additive_expr(&mut tokens.iter().peekable())
}

/// Additive expressions are things like `expr + expr`, or `expr - expr`. It reads a multiplicative
/// expr first, which allows precedence to exist.
fn parse_additive_expr<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    let mut expr = parse_multiplicative_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Plus || op == &Operator::Minus => {
                tokens.next();
                let r_expr = parse_multiplicative_expr(tokens)?;
                expr = Expr::BinOp(*op, Box::new(expr), Box::new(r_expr));
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// Multiplicative expressions are `expr * expr`, or `expr / expr`.
fn parse_multiplicative_expr<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    let mut expr = parse_parenthetical_multiplicative_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Star || op == &Operator::Slash => {
                tokens.next();
                let r_expr = parse_parenthetical_multiplicative_expr(tokens)?;
                expr = Expr::BinOp(*op, Box::new(expr), Box::new(r_expr));
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// Parenthetical, multiplicative expressions are just expressions times an expression wrapped in parenthesis: `expr(expr)`, which is
/// the same as `expr * expr`.
fn parse_parenthetical_multiplicative_expr<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    let mut expr = parse_power_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::LParen => {
                tokens.next();
                let mut internal_expr = parse_additive_expr(tokens)?;
                match tokens.next() {
                    Some(Token::Operator(op)) if op == &Operator::RParen => {
                        loop { // parse '^2' or likewise power expressions on individual parenthesis-covered expressions
                            match tokens.peek() {
                                Some(Token::Operator(op)) if op == &Operator::Caret => {
                                    tokens.next();
                                    let exponent = parse_factorial_expr(tokens)?;
                                    internal_expr = Expr::Pow(Box::new(internal_expr), Box::new(exponent));
                                }
                                _ => break,
                            }
                        }

                        expr = Expr::BinOp(Operator::Star, Box::new(expr), Box::new(internal_expr));
                    }
                    _ => return Err(ExpectedClosingParenthesis),
                }
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// Power expressions are any expressions with an exponential: `factor ^ factor`.
fn parse_power_expr<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    let mut expr = parse_factorial_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Caret => {
                tokens.next();
                let exponent = parse_factorial_expr(tokens)?;
                expr = Expr::Pow(Box::new(expr), Box::new(exponent));
            }
            _ => break,
        }
    }
    Ok(expr)
}

fn parse_factorial_expr<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    let expr = parse_factor(tokens)?;
    match tokens.peek() {
        Some(Token::Operator(Operator::Factorial)) => {
            tokens.next();
            Ok(Expr::Factorial(Box::new(expr)))
        }
        _ => Ok(expr),
    }
}

/// The most important item -- a factor. A factor is generally the bottom level ideas
/// like numbers or expressions in parenthesis. The factor makes the recursion in `Expr`
/// finite.
fn parse_factor<T: Clone>(tokens: &mut Peekable<Iter<Token<T>>>) -> ParserResult<T> {
    match tokens.next() {
        // Parenthetical expressions such as `(expr)`.
        Some(Token::Operator(Operator::LParen)) => {
            let expr = parse_additive_expr(tokens);
            match tokens.next() {
                Some(Token::Operator(Operator::RParen)) => expr,
                _ => Err(ExpectedClosingParenthesis),
            }
        }
        // Some(Token::Operator(Operator::Pipe)) => {
        //     let expr = parse_additive_expr(tokens)?;
        //     match tokens.next() {
        //         Some(Token::Operator(Operator::Pipe)) => Ok(Expr::Function(Function::Abs, Box::new(expr))),
        //         _ => return Err(ExpectedClosingPipe),
        //     }
        // }
        Some(Token::Identifier(id)) => {
            match tokens.peek() {
                // Functions (if next is LP or PIPE or NUM or ID)
                Some(Token::Operator(Operator::LParen)) => {
                    tokens.next(); // Consume '('
                    let expr = parse_additive_expr(tokens)?;
                    match tokens.next() {
                        Some(Token::Operator(Operator::RParen)) => Ok(Expr::Function(id.clone(), Box::new(expr))),
                        _ => Err(ExpectedClosingParenthesis),
                    }
                }
                Some(Token::Operator(Operator::Pipe)) => {
                    tokens.next(); // Consume '|'
                    let expr = parse_additive_expr(tokens)?;
                    match tokens.next() {
                        Some(Token::Operator(Operator::Pipe)) => Ok(Expr::Function(id.clone(), Box::new(expr))),
                        _ => return Err(ExpectedClosingPipe),
                    }
                }
                Some(Token::Operator(Operator::Minus)) => {
                    tokens.next(); // Consume '-'
                    Ok(Expr::Function(id.clone(), Box::new(Expr::Neg(Box::new(parse_factor(tokens)?)))))
                }
                Some(Token::Number(n)) => {
                    tokens.next(); // Consume number
                    Ok(Expr::Function(id.clone(), Box::new(Expr::Constant(n.clone()))))
                }
                Some(Token::Identifier(other_id)) => { // Function-in-a-function?
                    tokens.next(); // Consume identifier
                    Ok(Expr::Function(id.clone(), Box::new(Expr::Function(other_id.clone(), Box::new(parse_factor(tokens)?)))))
                }

                // Nope, definitely not a function: this is certainly either variable recall or variable assignment.
                t => match t {
                    Some(Token::Operator(Operator::Equals)) => {
                        tokens.next();
                        Ok(Expr::Assignment(id.clone(), Box::new(parse_additive_expr(tokens)?)))
                    }
                    _ => Ok(Expr::Identifier(id.clone())),
                }
            }
        }
        Some(Token::Operator(Operator::Minus)) => {
            Ok(Expr::Neg(Box::new(parse_factor(tokens)?))) // Unary negative expressions like `-factor`.
        }
        Some(Token::Number(n)) => Ok(Expr::Constant(n.clone())), // Number constants like `3`, `2.21`, `.34` or `-.2515262`.
        t => Err(ExpectedFactor(t.cloned())), // The token being read isn't in the right place.
    }
}
